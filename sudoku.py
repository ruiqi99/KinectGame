#this is the sudoku mode. In this mode, the player is expected to fill the 
#empty grids on the sudoku board by dragging numbers onto it. 
#if the player can finish the sudoku in limited time, he wins.
#The player can also choose to view solution. The solution is generated by 
#backtracking.

#CITATION: the frame work is from:
#https://github.com/fletcher-marsh/kinect_python
from pykinect2 import PyKinectV2, PyKinectRuntime
from pykinect2.PyKinectV2 import *

import ctypes
import _ctypes
import pygame
import sys
import math
import random
import copy

class GameRuntime(object):

    def __init__(self, mask = None):
        pygame.init()
        #CITATION: the background image is made by me by powerPoint
        self.BG = pygame.image.load("sudokuBG.png")
        self.BG = pygame.transform.scale(self.BG, (1920, 1080))
        self.headX, self.headY = -30, -30
        self.mask = mask
        if self.mask != None:
            self.mask = pygame.transform.scale(self.mask, (300, 300))
        self.screenWidth = 1920
        self.font = pygame.font.SysFont('mono', 39, bold=True)
        self.screenHeight = 1080
        self.curRightHandHeight = 500
        self.curRightHandX = 500
        self.curLeftHandHeight = 500
        self.curLeftHandX = 500
        self.prevLeftHandHeight = 0
        self.prevLeftHandX = 0
        self.prevRightHandHeight = 0
        self.prevRightHandX = 0
        self.gameover = False
        self.paused = False
        self.viewSol = False
        self.robPos = []
        self.score = 0
        self.end = False
        self.firstTime = True
        self.timeRemain = 30
        self.pink = (180, 120, 130)
        self.white = (255, 255, 255)
        self.blue = (97, 170, 195)
        self.pinkpink = (249, 140, 128)
        self.robRadLarge = 40
        self.robRadSmall = 25
        self.font = pygame.font.SysFont('mono', 24, bold=True)
        # Used to manage how fast the screen updates
        self.clock = pygame.time.Clock()
        # Set the width and height of the window [width/2, height/2]
        self.screen = pygame.display.set_mode((960, 540), \
        pygame.HWSURFACE|pygame.DOUBLEBUF, 32)
        # Loop until the user clicks the close button.
        self.done = False
        # Kinect runtime object, we want color and body frames 
        self.kinect = PyKinectRuntime.PyKinectRuntime\
        (PyKinectV2.FrameSourceTypes_Color | PyKinectV2.FrameSourceTypes_Body)
        # back buffer surface for getting Kinect color frames, 32bit color, 
        #width and height equal to the Kinect color frame size
        self.frameSurface = pygame.Surface((self.kinect.color_frame_desc.Width\
        , self.kinect.color_frame_desc.Height), 0, 32)
        #self.semiTrans = pygame.Surface((self.kinect.color_frame_desc.Width\
        #, self.kinect.color_frame_desc.Height),pygame.SRCALPHA , 32)
        self.new = pygame.Surface((self.kinect.color_frame_desc.Width\
        , self.kinect.color_frame_desc.Height), 0, 32)
        # here we will store skeleton data 
        self.bodies = None
        #this userPos stores the positions of user's left hand, 
        #right hand, and head.
        self.userPos = [[self.curLeftHandX, self.screenHeight - \
        self.curLeftHandHeight], [self.curRightHandX, self.screenHeight \
        - self.curRightHandHeight]]
        
        #get the sudokuboard
    

        self.questionFile = open("questions.txt", "r")
        questions = self.questionFile.readlines()
        #decide which question to use
        self.boardNum = random.choice(range(0, len(questions)))
        self.sudokuSol = questions[self.boardNum]
        self.questionList= [[] for time in range(0,9)]
        
        self.currentLine = 0
        self.thisSol = None

        for letter in self.sudokuSol:
            if letter.isdigit():
                if len(self.questionList[self.currentLine]) < 8:
                    self.questionList[self.currentLine].append(int(letter))
                else:
                    self.questionList[self.currentLine].append(int(letter))
                    self.currentLine += 1
        print(self.questionList)
        
        
        #randomly decide which block to remove
        if self.boardNum == 0:
            self.remove = random.choice([5,8])
        if self.boardNum == 1:
            self.remove = random.choice([5,8])
        self.removeCol = self.remove % 3
        self.removeRow = self.remove // 3
        
        self.sudokuBlank = copy.deepcopy(self.questionList)
        for row in range(3 * self.removeRow, 3 * self.removeRow + 3):
            for col in range(3 * self.removeCol, 3 * self.removeCol + 3):
                self.sudokuBlank[row][col] = None
        print(self.sudokuBlank)
        
        self.questionCopy = copy.deepcopy(self.sudokuBlank)
                
        #define position of the board
        self.sudokuBackX0 = 200
        self.sudokuBackY0 = 200
        self.sudokuBackWidth = 750
        self.sudokuBackX1 = self.sudokuBackX0 + self.sudokuBackWidth
        self.sudokuBackY1 = self.sudokuBackY0 + self.sudokuBackWidth  
        self.unit = round(750/9, 2)  
        
        self.removeX0 = self.sudokuBackX0 + self.removeCol * 3 * self.unit
        self.removeY0 = self.sudokuBackY0 + self.removeRow * 3 * self.unit
        
        
        #import the sudoku background
        #CITATION: I generate the following image by using Microsoft PowerPoint
        self.sudokuBackImg = pygame.image.load("sudokuBoard.png")
        self.sudokuBackImg = pygame.transform.scale(self.sudokuBackImg,\
         (self.sudokuBackWidth, self.sudokuBackWidth))
        
        #a list of numbers that the users can use
        self.nums = [0,1,2,3,4,5,6,7,8,9]
        self.buttonX0 = 1150
        self.buttonY0 = 100
        self.buttonX1 = 1150
        self.buttonY1 = 1000
        self.buttonUnit = round((1000 - 100) / 10, 2)
        
        #what is the number on the user's hand
        self.leftNum = None
        self.rightNum = None
        #whether the user is grabbing
        self.leftGrabbing = False
        self.rightGrabbing = False

    def drawMask(self):
        if self.mask != None:
            self.frameSurface.blit(self.mask,(960 + 1400 * self.headX - 80,  540 - 1300 * self.headY - 170))
        
            
    def isThisFillValid(self, L, row, col):
        firstSeen = set()
        secondSeen = set()
        for col in range(0, 9):
            ele = L[row][col]
            if ele == None:
                continue
            else:
                if ele in firstSeen:
                    secondSeen.add(ele)
                else:
                    firstSeen.add(ele)
        if len(secondSeen) != 0:
            return False
        
        firstSeen = set()
        secondSeen = set()
        for row in range(0, 9):
            ele = L[row][col]
            if ele == None:
                continue
            else:
                if ele in firstSeen:
                    secondSeen.add(ele)
                else:
                    firstSeen.add(ele)
        if len(secondSeen) != 0:
            return False
        
        rowStart = row // 3
        colStart = col // 3
        firstSeen = set()
        secondSeen = set()
        for row in range(rowStart * 3, rowStart * 4):
            for col in range(colStart * 3, colStart * 4):
                ele = L[row][col]
                if ele == None:
                    continue
                else:
                    if ele in firstSeen:
                        secondSeen.add(ele)
                    else:
                        firstSeen.add(ele)
        if len(secondSeen) != 0:
            return False
        return True


    def fillsuDo(self, L):
        if self.suDoCheck(L) == True:
            return L
        for row in range(0, 9):
            for col in range(0, 9):
                if L[row][col] == None:
                    for i in range(1, 10):
                        L[row][col] = i
                        if self.isThisFillValid(L, row, col) == True:
                            tmpSol = self.fillsuDo(L)
                            if tmpSol != None:
                                return tmpSol
                        else:
                            L[row][col] = None
        return None
    

    def suDoCheck(self, L):
        for row in range(0, 9):
            pool = set([1,2,3,4,5,6,7,8,9])
            for col in range(9):
                ele = L[row][col]
                if ele == None:
                    return False
                try:
                    pool.remove(ele)
                except:
                    return False
        
        for col in range(0, 9):
            pool = set([1,2,3,4,5,6,7,8,9])
            for row in range(0, 9):
                ele = L[row][col]
                if ele == None:
                    return False
                try:
                    pool.remove(ele)
                except:
                    return False
        
        for col in [0, 3, 6]:
            for row in [0, 3, 6]:
                pool = set([1,2,3,4,5,6,7,8,9])
                for thisCol in range(col, col + 3):
                    for thisRow in range(row, row + 3):
                        ele = L[thisRow][thisCol]
                        try:
                            pool.remove(ele)
                        except:
                            return False
        return True
    
    
    def ifInEmptyBox(self):
        #left
        if self.removeX0 < self.userPos[0][0] < self.removeX0 + 3 * self.unit:
            if self.removeY0 < self.userPos[0][1] < \
            self.removeY0 + 3 * self.unit:
                if self.leftGrabbing == False and self.leftNum != None:
                    innerCol = (self.userPos[0][0] - self.removeX0) // self.unit
                    innerRow = (self.userPos[0][1] - self.removeY0) // self.unit
                    col = round(self.removeCol * 3 + innerCol)
                    row = round(self.removeRow * 3 + innerRow)
                    self.sudokuBlank[row][col] = round(self.leftNum)
                    self.leftNum = None

        #right
        if self.removeX0 < self.userPos[1][0] < self.removeX0 + 3 * self.unit:
            if self.removeY0 < self.userPos[1][1] < \
            self.removeY0 + 3 * self.unit:
                if self.rightGrabbing == False and self.rightNum != None:
                    innerCol = (self.userPos[1][0] - self.removeX0) // self.unit
                    innerRow = (self.userPos[1][1] - self.removeY0) // self.unit
                    col = round(self.removeCol * 3 + innerCol)
                    row = round(self.removeRow * 3 + innerRow)
                    self.sudokuBlank[row][col] = round(self.rightNum)
                    print(row, col, self.rightNum)
                    self.rightNum = None
                    
        
    def drawNumButtons(self):
        for idx in range(0, 10):
            num = self.nums[idx]
            x = self.buttonX0
            y = self.buttonY0 + self.buttonUnit * idx
            ra = 35
            pygame.draw.circle(self.frameSurface, 
                          self.blue, 
                          (int(x) + ra, int(y)+ ra) , self.robRadLarge + 3)
            self.drawANumber(x, y, num)
            

    def isTouchingNum(self):

        xLower = 1155
        xUpper = 1215
        yLower = 92
        yUpper = 988
        #LeftHand
        if xLower < self.userPos[0][0] < xUpper:
            if yLower < self.userPos[0][1] < yUpper:
                idx = (self.userPos[0][1] - 92) // 86
                if self.leftGrabbing:
                    self.leftNum = round(idx, 0)
    
        #rightHand
        if xLower < self.userPos[1][0] < xUpper:
            if yLower < self.userPos[1][1] < yUpper:
                idx = (self.userPos[1][1] - 92) // 86
                if self.rightGrabbing:
                    self.rightNum = round(idx, 0)
    
    
    
    
    def drawBackground(self):
        self.frameSurface.blit(self.sudokuBackImg, (self.sudokuBackX0, self.sudokuBackY0))
       
    def drawANumber(self, x, y, num):
        marg = 17
        pygame.font.init()
        #CITATION:  the following font is copied and revise from website:
        #https://programtalk.com/python-examples/pygame.font.SysFont/
        font1 = pygame.font.SysFont('mono', 50, bold = True, italic = True)
        text = font1.render(str(num), 1, (0,0,0))
        self.frameSurface.blit(text, (x + marg, y + marg))
        
    def drawNumbers(self, L):
        for rowIdx in range(0, 9):
            for colIdx in range(0,9):
                number = L[rowIdx][colIdx]
                x = self.sudokuBackX0 + self.unit * colIdx
                y = self.sudokuBackY0 + self.unit * rowIdx
                if number != None:
                    self.drawANumber(x, y, number)
        
    
    def drawColorFrame(self, frame, targetSurface):
        targetSurface.lock()
        address = self.kinect.surface_as_array(targetSurface.get_buffer())
        ctypes.memmove(address, frame.ctypes.data, frame.size)
        del address
        targetSurface.unlock()
    
    #this function draws two blue dots at the user's hands
    def drawDot(self):
        for item in self.userPos:
            idx = self.userPos.index(item)
            if idx == 0:
                numToDraw = self.leftNum
            if idx == 1:
                numToDraw = self.rightNum
            
            pygame.draw.circle(self.frameSurface, 
                          self.blue, 
                          (int(item[0]), 
                           int(item[1])), self.robRadLarge)
            if numToDraw != None:
                margin = 5
                text = self.font.render(str(int(numToDraw)), 1, (0, 0, 0))
                self.frameSurface.blit(text, (int(item[0]) - margin, 
                           int(item[1]) - margin))
                

    #this function randomly generate new targets(it also makes sure that the 
    #new position should have some distance from the user's hand)
    def isInBox(self, x, y):
        if x < 400 and y < 200 :
            return False
        return True
    

    def isValidNewPos(self, ax, ay, prevax, prevay):
        rad = 500
        dis = self.calculateDis(ax, ay, prevax, prevay)
        if dis >= rad:
            return True
        return False
        
    #calculate the distance between two points
    def calculateDis(self, ax, ay, bx, by):
        dis = ((ax - bx) ** 2 + (ay - by) ** 2) ** 0.5
        return dis
                           
                           
    def isCollide(self, x1, y1, x2, y2):
        allowError = 40
        dis = self.calculateDis(x1, x2, y1, y2)
        if dis < allowError:
            print("Congrat!")
            return True
        return False
        
    #draw the information: current score and time remaining
    def drawInfo(self, thisTime):
        pygame.font.init()
        font1 = pygame.font.SysFont('mono', 39, bold=True)
        text = font1.render("Score:" + str(self.score), 1, (0, 0, 0))
        text2 = font1.render("Time:" + str(round(200 - thisTime, 1)), \
        1, (0, 0, 0))
        self.frameSurface.blit(text, (100,100))
        self.frameSurface.blit(text2, (100,150))
    
    #draw a white background for the info
    def drawInfoBackGround(self):
        pygame.draw.rect(self.frameSurface, (255, 255, 255), \
        (0, 0, 400, 200))
    
    #a start page, user move mouse over start button to start
    
    def startPage(self):
        while self.firstTime == True:
            #CITATION: the next four lines are from 
            #https://pythonprogramming.net/pygame-button-function-events/
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    quit()
                    

            pygame.draw.rect(self.frameSurface, (255, 255, 255, 100), \
        (0, 0, self.kinect.color_frame_desc.Width\
        , self.kinect.color_frame_desc.Height))
            margin = 200
            textMargin = 230
            width = 1600
            self.frameSurface.blit(self.BG, (0,0))
            
            
            boxAx, boxAy, boxBx, boxBy = 1580, 880, 930, 200
            pygame.draw.rect(self.frameSurface, (0,0,0), \
            (boxAx, boxAy, boxBx, boxBy))
            
            pygame.font.init()
            fontColR, fontColG, fontColB = 232, 171, 0

            text2MarX, text2MarY = 1620, 940
            fontSize = 70
            font1 = pygame.font.SysFont('mono', fontSize, bold=True)
            text2 = font1.render("Start" , 1, \
            (fontColR, fontColG, fontColB))
            self.frameSurface.blit(text2, (text2MarX, text2MarY))
            
            mouse = pygame.mouse.get_pos()
            xMin = 1580
            xMax = 2000
            yMin = 880
            yMax = 2000
            if xMin < mouse[0] * 2 < xMax and yMin < mouse[1] * 2 < yMax:
                self.firstTime = False
                break

            hToW = float(self.frameSurface.get_height()) / self.\
            frameSurface.get_width()
            targetHeight = int(hToW * self.screen.get_width())
            surfaceToDraw = pygame.transform.scale(self.frameSurface\
            , (self.screen.get_width(), targetHeight));
            self.screen.blit(surfaceToDraw, (0,0))
            surfaceToDraw = None # memory save
            pygame.display.update()
    
    def drawViewSol(self):

        pygame.draw.rect(self.frameSurface, self.pinkpink,\
         (1400, 500, 400, 200))
        pygame.font.init()
        font1 = pygame.font.SysFont('mono', 39, bold=True)
        text = font1.render("View Solution!", 1, (0, 0, 0))
        self.frameSurface.blit(text, (1430, 580))
    
    def ifViewSol(self):
        mouse = pygame.mouse.get_pos()
        xMin = 700
        xMax = 900
        yMin = 250
        yMax = 350
        if xMin < mouse[0] < xMax and yMin < mouse[1] < yMax:
            print("tes")
            self.viewSol = True


    def run(self):
        pygame.font.init()
        # -------- Main Program Loop -----------

        while not self.done:
            self.new.fill((255, 120, 234))

            thisTime = pygame.time.get_ticks() / 1000

            self.timeRemain = int(30 - thisTime)
            if thisTime > 200:
                self.end = True
                self.done = True

 
            
            pygame.display.flip()
            self.screen.blit(self.frameSurface, (0, 0))
            #self.screen.blit(self.semiTrans, (0,0))

            # --- Main event loop
            for event in pygame.event.get(): # User did something
                if event.type == pygame.QUIT: # If user clicked close
                    self.done = True 
                #CITATION: the following two lines:
                #https://stackoverflow.com/questions/30744237
                #/how-to-create-a-pause-button-in-pygame
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_p:
                        self.paused = True
                        self.stop()

                    # Flag that we are done so we exit this loop
            # We have a color frame. Fill out back buffer surface 
            #with frame's data 

            if self.kinect.has_new_color_frame():
                frame = self.kinect.get_last_color_frame()
                self.drawColorFrame(frame, self.frameSurface)
                frame = None # memory save
                
            if self.kinect.has_new_body_frame(): 
                self.bodies = self.kinect.get_last_body_frame()

                if self.bodies is not None: 
                    for i in range(0, self.kinect.max_body_count):
                        body = self.bodies.bodies[i]
    
                        if not body.is_tracked: 
                            continue 

                        joints = body.joints 
                        # save the hand positions
                        basicPosY = self.screenHeight / 2
                        basicPosX = self.screenWidth / 2
                        ratio = 1600
                        if joints[PyKinectV2.JointType_HandRight].\
                        TrackingState != PyKinectV2.TrackingState_NotTracked:
                            self.curRightHandHeight = basicPosY +\
                             joints[PyKinectV2.JointType_HandRight].\
                             Position.y * ratio
                            self.curRightHandX = basicPosX +\
                             joints[PyKinectV2.JointType_HandRight].\
                             Position.x * ratio
                            
                            
                        if joints[PyKinectV2.JointType_HandLeft].\
                        TrackingState != PyKinectV2.TrackingState_NotTracked:
                            self.curLeftHandHeight = basicPosY \
                            + joints[PyKinectV2.JointType_HandLeft].\
                            Position.y * ratio
                            self.curLeftHandX = basicPosX + joints\
                            [PyKinectV2.JointType_HandLeft].Position.x * ratio
                        #CITATION: the syntax of the next eight lines is from:
                        #https://github.com/Te12944265
                        #-AMAHA/ESCAPE/blob/master/StartGame.py
                        if body.hand_left_state == 3:
                            self.leftGrabbing = True
                        else:
                            self.leftGrabbing = False
                        if body.hand_right_state == 3:
                            self.rightGrabbing = True
                        else:
                            self.rightGrabbing = False
                        
                        self.userPos = [[self.curLeftHandX, self.screenHeight \
                        - self.curLeftHandHeight],[self.curRightHandX, \
                        self.screenHeight - self.curRightHandHeight]] 
                        
                        #store the previous information
                        self.prevLeftHandHeight = self.curLeftHandHeight
                        self.prevLeftHandX = self.curRightHandX
                        self.prevRightHandHeight = self.curRightHandHeight
                        self.prevRightHandX = self.curRightHandX
                        #CITATION: the following code of tracking head is from:
                        #https://github.com/jtaceron/Kinect-Fruit-Ninja
                        if joints[PyKinectV2.JointType_Head].TrackingState != PyKinectV2.TrackingState_NotTracked:
                            self.headX = joints[PyKinectV2.JointType_Head].Position.x  
                            self.headY = joints[PyKinectV2.JointType_Head].Position.y 

            self.drawMask()
            
            self.isTouchingNum()
            self.ifInEmptyBox()
            res = self.suDoCheck(self.sudokuBlank)
            if res == True:
                self.done = True

 

            self.drawBackground()
            self.drawNumButtons()
            self.drawInfoBackGround()
            self.drawInfo(thisTime)
            self.drawDot()
            self.drawViewSol()
            self.ifViewSol()
            self.drawNumbers(self.sudokuBlank)
            if self.viewSol == True and self.thisSol == None:
                self.thisSol = self.fillsuDo(self.questionCopy)
               # print(self.thisSol)
            if self.thisSol != None:
                self.drawNumbers(self.thisSol)
            
            hToW = float(self.frameSurface.get_height()) / self.frameSurface.\
            get_width()
            targetHeight = int(hToW * self.screen.get_width())
            surfaceToDraw = pygame.transform.scale(self.frameSurface, \
            (self.screen.get_width(), targetHeight));
            self.screen.blit(surfaceToDraw, (0,0))
            surfaceToDraw = None # memory save
            pygame.display.update()

            # --- Limit t o 60 frames per second
            self.clock.tick(60)
        # Close our Kinect sensor, close the window and quit.
        self.kinect.close()
        pygame.quit()

def runSudoku(mask):
    game = GameRuntime();
    game.startPage()
    #CITATION: the syntax of the next two lines is from:
    #https://stackoverflow.com/questions/7746263/
    #how-can-i-play-an-mp3-with-pygame
    pygame.mixer.music.load("BGM.MP3")
    pygame.mixer.music.set_volume(1)
    pygame.mixer.music.play()
    game.run()